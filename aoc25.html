<!DOCTYPE html>
<head>
	<title>Correct Arity</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advent of Code 2025">
    <meta name="keywords" content="aoc, advent, code, 2025, gleam, fold">
    <meta property="og:title" content="Correct Arity">
    <meta property="og:description" content="Advent of Code 2025">
    <meta property="og:image" content="https://correctarity.com/static/stars.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:alt" content="Preview image">
    <link rel="stylesheet" href="static/style.css">
    <link
      rel="icon"
      type="image/svg+xml"
      href="/static/icon.svg"
    />
</head>
<body>
    <h1><a href="/">Correct Arity</a></h1>
    <img src="/static/stars.png">
    <h2>Advent of Code 2025</h2>
    <h3>My advent of Gleam: hard then easy then hard</h3>
    <p>The first few problems I found hard because I was just starting to learn Gleam, so even things like parsing the input I was not sure about. The middle problems I flew through much more easily as I had learned more Gleam and the problems themselves were still not as bad relative to the final problems, which I found much trickier as problems themselves, regardless of language.</p>
    <p>My solutions are <a href="https://github.com/D-matz/aoc2025/blob/main/src/day1p1.gleam">here, eg day 1 part 1.</a> In that one I found int.modulo, which returns a result, without realizing a normal modulo % operator exists, so I ended up writing a totally redundant wrapper around int.modulo that just reimplements %.</p>
    <iframe height="300px" src="https://playground.gleam.run/#N4IgbgpgTgzglgewHYgFwEYA0IDGyAuES+aIcAtgA4JT4AEA5gDYQCG5A9HMQDpJ+UArgCM6AMyR1yrbgAoAlHWB86dCDgAWCOugBMAZjoBSHQAYVazdqgQAJoKS3WxAPoaITStFl79mM/J8AL58fBJ0NvaOzvhuHl5QskiC5Kh0AJLE/rZwYHAwNGmZ+IrKknQs9KwwMND0APIA1kmKALx03PgAdOQI9kwISSnZufk0geX8SEEgQUA="></iframe>
    <p>Learning a new language, I definitely tripped on stuff. Redundant modulo was not terrible, whereas a mistake that slowed me down a lot on day 2 pt 2 was assuming list.range would be empty if the second arg was lower, but in Gleam it counts down.</p>
    <iframe height="200px" src="https://playground.gleam.run/#N4IgbgpgTgzglgewHYgFwEYA0IDGyAuES+aIcAtgA4JT4AEA5gDYQCG5A9E3DPgDpIBlAK4AjOgDMkdcqzhIAFAEo6wAXToQcACwR1uvAHRRWSBhAUBOTHQCsSgQF8QjoA=="></iframe>
    <p>Which is totally reasonable; it just isn't what Python's range does, so my solution was slightly off for an input and it took me a while to figure out why.</p>
    <p>Still, Gleam felt fast and fun to learn. Like Go, I could pick it up and try a few tour examples and get to solving aoc problems pretty quickly. Unlike Go, the solutions felt satisying enough to motivate doing all the problems.</p>
    <p>After getting used to Gleam, many of the problems felt great, and I solved them on my own except day 10 pt 2 and day 12. For these I got so stuck I started reading other stuff including <a href="https://blog.tymscar.com/posts/gleamaoc2025/">Tymscar's blog</a> which mentioned the finale is troll and "the only puzzle I did not fully enjoy" which yeah I'd echo. For problem 10 pt 2 I copied a <a href="https://old.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/">brilliant approach from reddit</a>.</p>
    <h3>The Gleam playground is friendly</h3>
    <p>Gleam has a decent number of steps to install, so it's nice there's <a href="https://playground.gleam.run/">https://playground.gleam.run/</a>, it let me do a lot of the problems in an environment without Gleam installed.</p>
    <h3>echo and todo are friendly</h3>
    <p>echo and todo are great quality of life features: technically the same programs could be written without echo/todo, but I as a human would struggle without echo/todo. Specifically when lining up all the types to get Gleam to compile, echo is nice to slap on to something and see what it looks like, and todo lets you run the up to that point without fixing everything. So both help you test out half constructed programs and make Gleam "friendly", making the type system learning curve a lot easier.</p>
    <iframe height="250px" src="https://playground.gleam.run/#N4IgbgpgTgzglgewHYgFwEYA0IDGyAuES+aIcAtgA4JT4AEA5gDYQCG5A9ACZw74A6SQZQCuAIzoAzJHXKs4SABQBKOsEF06EHAAsEdAMSKsdAEyY6AbRPm6AZgC6mDZv4gA7jtb18AT0oQdHAwdPg6waHhSAwA/C5BXADWdGIi9Np6dO5wTEx0lFAK9HD0rEi+7qy+MG4W8Tx8AHRIEO4qdAA+AHx0DfiNCjDQ+IrWmKZOdABirExDysqCAL6CIEtAA"></iframe>
    <p>Also really like how echo automatically prints the line number so you can jump to the print. Would be nice if the playground had line numbers too. Still very nice though.</p>
    <h3>I can't index into an array?</h3>
    <p>
        Tymscar's blog mentions <a href="https://blog.tymscar.com/posts/gleamaoc2025/#options-everywhere-and-why-that-matters-for-grid-puzzles">problem 4</a>,
        I bet because the way to get an item in a 2d array and the items around it is very surprising when new to Gleam. Gleam really does not want you to do mylist[i+1][j-1].
        I got so mad I went looking for the commit where the maintainer removed list.at from the std lib to discourage indexing into a list:</p>
    <a href="https://github.com/gleam-lang/stdlib/commit/7a15388249b67a0119351f12b6e94d9777fbd10c">deprecate list.at</a>
    <a href="https://github.com/gleam-lang/stdlib/commit/b98705f890a2828c48dfdab291a22f145309d646">remove list.at</a>
    <blockquote>"Gleam lists are immutable linked lists, so indexing into them is a slow operation that must traverse the list. In functional programming it is very rare to use indexing, so if you are using indexing then a different algorithm or a different data structure is likely more appropriate."</blockquote>
    <p>They <em>really</em> do not want you indexing into a list. Personally that's how I'd naturally think about checking adjacent positions for problem 4 though.</p>
    <p>Instead I put the 2d array items into a dict where the (row index, col index) is the key, and as Tymscar says "The key ergonomic part is that dict.get gives you an option-like result, which makes neighbour checking safe by default." so you don't have to check if index is zero or max len before getting an adjacent value, which saved some work I expected to have to do. So in a sense it's nicer, although mostly for me it was different and unexpected.</p>
    <h3>What's the biggest set you can fit in memory?</h3>
    <p>For day 9 pt 2 I originally made a set of all green tiles, which was correct but crashed the playground on my computer. My solution that worked on the problem input may not have been totally correct - in the literal corner case where the green tiles are a thin layer around two sides of a square like pac-man with an open mouth it would count the square entirely outside the tiles - but for the actual problem input it was ok. Anyways, what are the general performance limits? On the playground on my computer a set of size 12345 seems fine but once you get to 12345678 it slows down noticeably.</p>
    <iframe height="400px" src="https://playground.gleam.run/#N4IgbgpgTgzglgewHYgFwEYA0IDGyAuES+aIcAtgA4JT4AEA5gDYQCG5A9DBPgDpIVqtRi3YcmcGHyT9KAVwBGdAGZI65VnCQAKAJR1g/OnRb0YALzoBeOugBMAZgAsAViMnJ+AHTKETACbaylAI5Kh03N5IEADueph0CJBQ4RJSXlCsSAwQ2gAMmBa6CTFw+AAW4ararDg4CXC6hmrGdLU4dAA+AHwRPF5a3LTaje4AvrruEDjlCBHm/GP8IGNAA==="></iframe>
    <h3>Double fold and functional programming elegance</h3>
    <p>Advent of code is full of "go through a list and for each item, add something to accumulator". Often a list of lists requires a nested fold with an outer accumulator and an inner accumulator. This tripped me up a lot at first because I'd name both "acc" and accidentally add to the wrong one. It seems like usually the one you want to use is the inner acc, so naming them "inner_acc" and "outer_acc" helped me keep them straight. Also, these two are equivalent:</p>
    <iframe height="550px" src="https://playground.gleam.run/#N4IgbgpgTgzglgewHYgFwEYA0IDGyAuES+aIcAtgA4JT4AEA5gDYQCG5A9E3DPgDpIBlAK4AjOgDMkdcqzhIAFAEo6wAXTot6cQuRh0AvHQDa6jSfRY66AEyZrAZgC6mMxuM2rNu3RvPX0ubGDlYONk5mEYFmEDgAFgiaPPgAdBIITAAmChJQCOSodAAM9giQUIU6EHr2AO46cYVSCgjChFAA+qw4OPZ5tUpqgRpadP0dMMLkhkm8aRnZufmFJXRl0IX9dQ1NivJI0F099lXkg27m+4fdOHQA1HSnFwC+Shet7Ue3D+OT5GavMwxeKJbhzdJZHJ5ArFUrlSq6GDbfCNSSKD7XY5jBADIbmWapCGLaGFDGdG5wjbY2rI1HNK7krGnc7DS5IA6M76PXQvN6BQFIZ4CEDPIA==="></iframe>
    <p>I feel like the second version is more elegant and some people would really prefer it, but I'm not sure. Imo this sort of thing where you start with one version and "improve" on it is sort of an anti pattern: it implies the first version is the one you'd first think of and the beautiful elegant solution is less obvious. Like the shorter nested fold code is probably more readable for experienced Gleam users, but is it readable for people who aren't as familiar? Again idk.</p>
    <p></p>
    <h3>Gleam is fun</h3>
    <p>The downside of the elegance is it's not as easy (for me) to figure out, but Gleam is simple and friendly enough I could get into it despite it being a functional language. The upside is once you figure a solution out it is really satisfying. I have never done a full aoc before, and tbh probably only did this one because only 12 days, but also because Gleam solutions feel great.</p>
    <p>Gleam is definitely fun for little aoc style problems; I hope it's still fun when things aren't as clean and self contained.</p>
    <a href="/aoc25tachyon">Day 7 (tachyon manifold) visualization</a>
</body>
